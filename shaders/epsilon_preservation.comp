#version 450

// Epsilon Preservation: Œµ‚Åª¬π : ‚àû ‚Üí ùüô
// Preserves evaluation back to proto-unity space (inverse of erasure)
// Upsamples reduced-resolution evaluation to full proto-unity resolution

layout(local_size_x = 16, local_size_y = 16) in;

// Epsilon parameters (same as forward)
layout(set = 0, binding = 0) uniform EpsilonParams {
    float energy_weight;
    float coherence_weight;
    float sparsity_weight;
    float quality_weight;
    uint reduction_factor;         // Spatial reduction factor (e.g., 8 = 512‚Üí64)
    float coherence_threshold;
} epsilon;

// Infinity state input (‚àû) - evaluation memory (reduced resolution: 64x64 for 512x512 output with factor=8)
layout(set = 0, binding = 1, rgba32f) readonly uniform image2D infinity_state;

// Proto-identity output (ùüô) - shared thinking state (full resolution)
layout(set = 0, binding = 2, rgba32f) writeonly uniform image2D proto_identity;

void main() {
    uvec3 id = gl_GlobalInvocationID;
    ivec2 proto_dims = imageSize(proto_identity);
    ivec2 eval_dims = imageSize(infinity_state);

    if (id.x >= uint(proto_dims.x) || id.y >= uint(proto_dims.y)) {
        return;
    }

    // Calculate which evaluation pixel this proto-unity pixel maps to
    uint N = epsilon.reduction_factor;
    if (N == 0) N = 8;  // Default reduction factor
    
    ivec2 eval_coord = ivec2(id.xy) / int(N);
    
    // Clamp to infinity state image bounds
    eval_coord.x = clamp(eval_coord.x, 0, eval_dims.x - 1);
    eval_coord.y = clamp(eval_coord.y, 0, eval_dims.y - 1);

    // Load infinity state value (‚àû)
    vec4 eval_val = imageLoad(infinity_state, eval_coord);

    // Expand evaluation back to proto-unity space
    // For now, use bilinear interpolation for smoother upsampling
    // Future: could use learned upsampling filters
    
    // Simple nearest-neighbor upsampling (fast, GPU-friendly)
    vec4 proto_val = eval_val;

    // Write to proto-identity (ùüô) output
    imageStore(proto_identity, ivec2(id.xy), proto_val);
}

